# coding: utf-8
#!/usr/bin/env python
import numpy as np
import scipy 
from sklearn.gaussian_process import GaussianProcessRegressor

#------------------------------------------------------------------------------
def expected_improvement_closed_form(m,s):
    """ Analytical form of the EI
    """
    with np.errstate(divide='ignore'):
        EI = np.sqrt(s)*scipy.stats.norm.pdf(m/np.sqrt(s)) + m*scipy.stats.norm.cdf(m/np.sqrt(s))
        EI[s < 1e-9] = 0.0
    return EI

#------------------------------------------------------------------------------

def gp_EI_computation(gp, X_, y_mean =None, y_std = None):
    """ Compute the EI for a gp
    """
    if X_.ndim == 1:
        X_ = np.atleast_2d(X_).T
        
    if y_mean is None or y_std is None:
        # print ' No prediction in input, predictions will be computed'
        y_mean, y_std = gp.predict(np.atleast_2d(X_), return_std=True)


    pos_current_minimum = np.argmin(gp.y_train_)
    current_minimum = gp.y_train_[pos_current_minimum]
    m = current_minimum - y_mean
    s = y_std
    return expected_improvement_closed_form(m,s)

#------------------------------------------------------------------------------

def acquisition_maxEI_brute(gp,X_):
    """
    Returns maximum value of EI computed by brute force
    """
    EI_computed = acq.gp_EI_computation(gp,X_)
    return X_[np.argmax(EI_computed)]

#------------------------------------------------------------------------------


def acquisition_maxEI_analytical_gradientfree(gp,X_,nrestart, bounds):
    """
    Return maximum value of EI computed with gradient free optimization
    """
    EI_lambda = lambda value_considered: -acq.gp_EI_computation(gp,np.atleast_2d(value_considered))
    optim_number = 1
    rng = np.random.RandomState()
    dim = gp.X_train_.shape[1]
    if bounds is None:
        bounds = dim*[(0,1)]
    x0 = [rng.uniform(bds[0],bds[1],1) for bds in bounds]

    maxEI = scipy.optimize.minimize(EI_lambda, x0 = x0, bounds = bounds)

    while optim_number <= nrestart:
        x0 = [rng.uniform(bds[0],bds[1],1) for bds in bounds]
        optim = scipy.optimize.minimize(EI_lambda, x0 = x0, bounds = bounds) #dim*[(0,5)]
        if optim.fun < maxEI.fun:
            maxEI = optim
        optim_number += 1
    return maxEI.x


#------------------------------------------------------------------------------

def gp_qEI_computation(gp, qPoints, nsim = 1000):
    """
    qPoints : [npoints,q]
    """
    qPoints = np.atleast_2d(qPoints)
    npoints = qPoints.shape[0]
    qEI = np.empty(npoints)
    for i in xrange(npoints):
        y_mean, q_cov = gp.predict(qPoints[i,:,np.newaxis], return_cov = True)
        samples_MC = scipy.stats.multivariate_normal.rvs(y_mean, q_cov, nsim)
        minY = np.min(gp.y_train_)
        qEI[i] = np.mean(minY>samples_MC.min(1))
    return qEI
